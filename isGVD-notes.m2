-* QUESTIONS/NOTES *-

-- Need error catching
-- Feature idea: check for GVD up to substitution?

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

loadPackage "PrimaryDecomposition"  -* to check unmixedness *-
loadPackage "Depth"  -* for a CM check in isGVD *-

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (visible to end user) *-

--------------------------------------------------------------------------------

-* create a list of weights for the indeterminates in the ring *-

ringWeights = method()
ringWeights(RingElement) := y -> (
  -* y will be weighted 10, the rest of the indeterminates will be weighted 0 *-

  R := ring y;
  indets := gens R;
  weights := append( splice{ (#indets-1):0 } , 10);
  switch(index y, -1, weights)
  )

--------------------------------------------------------------------------------

-* define a new ring with a subset of the indeterminates, removing y *-

contractRing = method()
contractRing(RingElement) := y -> (
  -* create a new ring which has all the indeterminates of R except y *-
  indets := gens ring y;
  newIndets := delete(y, indets);
  QQ[newIndets]
  )

--------------------------------------------------------------------------------

-* check if C_{y, I} \cap (N_{y,I} + \langle y \rangle) = in_y(I) *-

-* NOTES *-
-* Possible error: what if I is zero/unit? It shouldn't be. If it's called from the main isGVD code, then we will have already checked this case. But if this function is called directly. Maybe we just have sub(I,R) as well to catch this. *-
-* check monomial orders here *-
-* do we need this? Or is it not called? *-

isValidGVD = method()
isValidGVD(Ideal, Ideal, RingElement, Ideal) := (C, N, y, I) -> (
  R := ring I;
  C := sub(C, R);
  N := sub(N, R);
  I := sub(I, R);
  intersect(C, N + ideal(y)) == ideal leadTerm(1,I)
  )

--------------------------------------------------------------------------------

-* check if ideal is squarefree ~~with an option to check only~~ with respect to one indeterminate *-
-* there's already `isSquareFree`, but it only works for monomial ideals. I think it would suffice to: set the custom weighting with y weighted 10, everything else 0, then run isSquareFree on the initial ideal. Is that equivalent? *-
-* assuming that this is ok, then here's an implementation *-

isSquareFreeInY = method()
isSquareFreeInY(Ideal, RingElement) := (I, y) -> (

  R := ring I;
  weights := ringWeights(R, y);
  R := QQ[gens R, MonomialOrder=>{Weights=>weights}, Global=>false];

  I := sub(I, R);
  isSquareFree monomialIdeal leadTerm I
  )

-* would still be good to know whether the whole ideal is squarefree? *-
-* this can be computationally intensive; leadTerm computes a GrÃ¶bner basis *-

isIdealSquareFree = method()
isIdealSquareFree(Ideal) := I -> (
  R := ring I;
  indets := gens R;
  all(apply(indets, y -> isSquareFreeInY(I, y)))
  )

--------------------------------------------------------------------------------

-* check if an ideal is unmixed *-

-* NOTES *-
-* Again, I have the problem with subbing into the current ring *-

isUnmixed = method()
isUnmixed(Ideal) := I -> (
  R := ring I;
  I := sub(I, R);
  D := primaryDecomposition I;
  d := apply(D, i -> dim(R/i));
  all(apply(d, i -> (i == d_0)), true)  -* list only contains true values *-
  )

--------------------------------------------------------------------------------

-* check if an ideal is generated by indeterminates *-
-* usual issue with (not) knowing R *-

isGeneratedByIndeterminates = method()
isGeneratedByIndeterminates(Ideal) := I -> (
  R := ring I;
  indets := gens R;
  gensI := first entries gens I;
  isSubset(gensI, indets)
  )


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (invisible to end user) *-

--------------------------------------------------------------------------------

-* print function, prints only if asked *-

printIf = method()
printIf(Boolean, String) := (bool, str) -> (
  if bool then print str
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* BIG FUNCTIONS *-

--------------------------------------------------------------------------------

-* do one step of a GVD: take I, find a GB; get C, N; check that they're unmixed and form a GVdecomp *-

-* --> need to decide where unmixedness checks happen *-
-* --> if it's when we compute C, N, then we need to pass that info to the isGVD function to not check it twice *-

-- with regards to isGVD, it is better to check to unmixedness here
-- but for the single step, we don't need C and N to be unmixed

oneStepGVD(Ideal, RingElement) := (I, y) -> (
  R := ring I;
  indets := gens R;
  indets := switch(0, index y, indets);
  R := QQ[indets, MonomialOrder=>Lex];

  I := sub(I, R);
  inyForm := leadTerm(1,I);
  G := gens gb I;

  squarefree := true;
  gensC := {};
  gensN := {};

  for g in first entries G do (
    deg := degree(y, g);
    if deg == 0 then (
      gensC := append(gensC, g);
      gensN := append(gensN, g);
      ) else (
      if deg == 1 then (
        gensC := append(gensC, sub(g, {y=>1}));
        ) else squarefree := false
      )
    )

  C := ideal(gensC);
  N := ideal(gensN);

  -- Klein, Rajchgot. Lemma 2.6.
  if not squarefree then (
    print("Warning: Groebner basis not squarefree in " | toString y)
    return {false, C, N}
    )

  -- check that the intersection holds
  validOneStep := ( intersect(C, N + ideal(y)) == ideal leadTerm(1,I) );

  if not validOneStep then (
    print("Warning: not a valid geometric vertex decomposition")
    return {false, C, N}
    )

  -- check unmixedness of both C and N
  isUnmixedC := isUnmixed C;
  isUnmixedN := isUnmixed N;

  -- issue with unmixedness check is here: technically we don't need it for the one step, but it is good to know for the whole isGVD
  if not (isUnmixedC or isUnmixedN) then (
    print("Warning: neither C nor N are unmixed")
    return {false, C, N}
    ) else (
      if not isUnmixedC then (
        print("Warning: C is not unmixed")
        return {false, C, N}
        )
      if not isUnmixedN then (
        print("Warning: N is not unmixed")
        return {false, C, N}
        )
      )

  -- redefine the ring and substitute C, N into the new ring
  R = (coefficientRing R)[ delete(y, indets) , MonomialOrder=>Lex];  -- notice this ring is defined globally
  C := sub(C, R);
  N := sub(N, R);

  return {true, C, N}
  )

--------------------------------------------------------------------------------

-* big isGVD, does the whole recursion thing *-

isGVD = method()
isGVD(Ideal) := I -> (
  if I == 0 or I == 1 or isGeneratedByIndeterminates I then return true
  if not (isUnmixed I) then return false

  -* original code doesn't run this check every time; set up the option for that *-
  if isHomogeneous I and not isCM(R/I) then return false

  for y in (gens R) do (




    )

  -* if we are here, no indeterminate worked; return false *-
  return false
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
