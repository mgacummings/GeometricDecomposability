-* QUESTIONS/NOTES *-

-- Need error catching
-- Feature idea: check for GVD up to substitution?

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

loadPackage "PrimaryDecomposition"  -* to check unmixedness *-
loadPackage "Depth"  -* for a CM check in isGVD *-

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (visible to end user) *-

--------------------------------------------------------------------------------

-* create a list of weights for the indeterminates in the ring *-

ringWeights = method()
ringWeights(RingElement) := y -> (
  -* y will be weighted 10, the rest of the indeterminates will be weighted 0 *-

  R := ring y;  -- I think this should work? Check.
  indets := gens R;
  weights := append( splice{ (#indets-1):0 } , 10);
  switch(index y, -1, weights)
  )

--------------------------------------------------------------------------------

-* define a new ring with a subset of the indeterminates *-

contractRing = method()
contractRing(RingElement) := y -> (
  -* create a new ring which has all the indeterminates of R except y *-
  R := ring y;  -- I think this should work? Check.
  indets := gens R;
  newIndets := delete(y, indets);
  QQ[newIndets]
  )

--------------------------------------------------------------------------------

-* check if C_{y, I} \cap (N_{y,I} + \langle y \rangle) = in_y(I) *-

-* NOTES *-
-* Possible error: what if I is zero/unit? It shouldn't be. If it's called from the main isGVD code, then we will have already checked this case. But if this function is called directly. Maybe we just have sub(I,R) as well to catch this. *-
-* check monomial orders here *-
-* do we need this? Or is it not called? *-

isValidGVD = method()
isValidGVD(Ideal, Ideal, RingElement, Ideal) := (C, N, y, I) -> (
  R := ring I;
  C := sub(C, R);
  N := sub(N, R);
  I := sub(I, R);
  intersect(C, N + ideal(y)) == ideal leadTerm(1,I)
  )

--------------------------------------------------------------------------------

-* check if ideal is squarefree ~~with an option to check only~~ with respect to one indeterminate *-
-* there's already `isSquareFree` , but it only works for monomial ideals. I think it would suffice to: set the custom weighting with y weighted 10, everything else 0, then run isSquareFree on the initial ideal. Is that equivalent? *-
-* assuming that this is ok, then here's an implementation *-

isSquareFreeInY = method()
isSquareFreeInY(Ideal, RingElement) := (I, y) -> (

  R := ring I;
  weights := ringWeights(R, y);
  R := QQ[gens R, MonomialOrder=>{Weights=>weights}, Global=>false];

  I := sub(I, R);
  isSquareFree monomialIdeal leadTerm I
  )

-* would still be good to know whether the whole ideal is squarefree? *-
-* this can be computationally intensive -- leadTerm computes a GrÃ¶bner basis when an ideal is passed *-

isIdealSquareFree = method()
isIdealSquareFree(Ideal) := I -> (
  R := ring I;
  indets := gens R;
  all(apply(indets, y -> isSquareFreeInY(I, y)))
  )

--------------------------------------------------------------------------------

-* check if an ideal is unmixed *-

-* NOTES *-
-* Again, I have the problem with subbing into the current ring *-

isUnmixed = method()
isUnmixed(Ideal) := I -> (
  R := ring I;
  I := sub(I, R);
  D := primaryDecomposition I;
  d := apply(D, i -> dim(R/i));
  all(apply(d, i -> (i == d_0)), true)  -* list only contains true values *-
  )

--------------------------------------------------------------------------------

-* check if an ideal is generated by indeterminates *-
-* usual issue with (not) knowing R *-

isGeneratedByIndeterminates = method()
isGeneratedByIndeterminates(Ideal) := I -> (
  R := ring I;
  indets := gens R;
  gensI := first entries gens I;
  isSubset(gensI, indets)
  )


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (invisible to end user) *-

--------------------------------------------------------------------------------

-* print function, prints only if asked *-

printIf = method()
printIf(Boolean, String) := (bool, str) -> (
  if bool then print str
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* BIG FUNCTIONS *-

--------------------------------------------------------------------------------

-* do one step of a GVD: take I, find a GB; get C, N; check that they're unmixed and form a GVdecomp *-

-* --> need to decide where unmixedness checks happen *-
-* --> if it's when we compute C, N, then we need to pass that info to the isGVD function to not check it twice *-

oneStepGVD(Ideal) := I -> (

  )

--------------------------------------------------------------------------------

-* big isGVD, does the whole recursion thing *-

isGVD = method()
isGVD(Ideal) := I -> (
  if I == 0 or I == 1 or isGeneratedByIndeterminates I then return true
  if not (isUnmixed I) then return false

  -* original code doesn't run this check every time; set up the option for that *-
  if isHomogeneous I and not isCM(R/I) then return false

  for y in (gens R) do (




    )

  -* if we are here, no indeterminate worked; return false *-
  return false
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
