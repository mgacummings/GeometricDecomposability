--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

loadPackage "PrimaryDecomposition"  -* to check unmixedness *-
loadPackage "Depth"  -* for a CM check in isGVD *-

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (visible to end user) *-

--------------------------------------------------------------------------------

-* create a list of weights for the indeterminates in the ring *-
-- I don't think we need this

ringWeights = method()
ringWeights(RingElement) := y -> (
  -* y will be weighted 10, the rest of the indeterminates will be weighted 0 *-

  R := ring y;
  indets := gens R;
  weights := append( splice{ (#indets-1):0 } , 10);
  switch(index y, -1, weights)
  )

--------------------------------------------------------------------------------

-* define a new ring with a subset of the indeterminates, removing y *-

-- I don't think we need this; we handle this within oneStepGVD and it is not of independent interest

contractRing = method()
contractRing(RingElement) := y -> (
  -* create a new ring which has all the indeterminates of R except y *-
  indets := gens ring y;
  newIndets := delete(y, indets);
  QQ[newIndets]
  )

--------------------------------------------------------------------------------

-* check if C_{y, I} \cap (N_{y,I} + \langle y \rangle) = in_y(I) *-

-- is this worth having as a separate function? It is easy to check just within oneStepGVD

-* NOTES *-
-* Possible error: what if I is zero/unit? It shouldn't be. If it's called from the main isGVD code, then we will have already checked this case. But if this function is called directly. Maybe we just have sub(I,R) as well to catch this. *-
-* check monomial orders here *-
-* do we need this? Or is it not called? *-

isValidGVD = method()
isValidGVD(Ideal, Ideal, RingElement, Ideal) := (C, N, y, I) -> (
  R := ring I;
  C := sub(C, R);
  N := sub(N, R);
  I := sub(I, R);
  intersect(C, N + ideal(y)) == ideal leadTerm(1,I)
  )

--------------------------------------------------------------------------------

-- neither of these are used elsewhere, remove?

-* check if ideal is squarefree ~~with an option to check only~~ with respect to one indeterminate *-
-* there's already `isSquareFree`, but it only works for monomial ideals. I think it would suffice to: set the custom weighting with y weighted 10, everything else 0, then run isSquareFree on the initial ideal. Is that equivalent? *-
-* assuming that this is ok, then here's an implementation *-

isSquareFreeInY = method()
isSquareFreeInY(Ideal, RingElement) := (I, y) -> (

  R := ring I;
  weights := ringWeights(R, y);
  R := QQ[gens R, MonomialOrder=>{Weights=>weights}, Global=>false];

  I := sub(I, R);
  isSquareFree monomialIdeal leadTerm I
  )

-* would still be good to know whether the whole ideal is squarefree? *-
-* this can be computationally intensive; leadTerm computes a Gröbner basis *-

isIdealSquareFree = method()
isIdealSquareFree(Ideal) := I -> (
  R := ring I;
  indets := gens R;
  all(apply(indets, y -> isSquareFreeInY(I, y)))
  )

--------------------------------------------------------------------------------

-* check if an ideal is unmixed *-

isUnmixed = method()
isUnmixed(Ideal) := I -> (
  R := ring I;
  D := primaryDecomposition I;
  d := apply(D, i -> dim(R/i));
  all(apply(d, i -> (i == d_0)), true)  -- list only contains true values
  )

--------------------------------------------------------------------------------

-* check if an ideal is generated by indeterminates *-

isGeneratedByIndeterminates = method()
isGeneratedByIndeterminates(Ideal) := I -> (
  R := ring I;
  indets := gens R;
  gensI := first entries gens I;
  isSubset(gensI, indets)
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (invisible to end user) *-

--------------------------------------------------------------------------------

-* print function, prints only if asked *-

printIf = method()
printIf(Boolean, String) := (bool, str) -> (
  if bool then print str
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* BIG FUNCTIONS *-

--------------------------------------------------------------------------------

-* do one step of a GVD: take I, find a GB; get C, N; check that they're unmixed and form a GVdecomp *-

oneStepGVD(Ideal, RingElement) := (I, y) -> (

  -- set up the ring
  R := ring I;
  indets := gens R;
  indets := switch(0, index y, indets);
  R := QQ[indets, MonomialOrder=>Lex];
  I := sub(I, R);

  -- get initial y-form and Gröbner basis
  inyForm := ideal leadTerm(1,I);
  G := gens gb I;

  squarefree := true;  -- we only care about the GB being squarefree in y
  gensC := {};
  gensN := {};

  for g in (first entries G) do (
    deg := degree(y, g);
    if deg == 0 then (
      gensC := append(gensC, g);
      gensN := append(gensN, g);
      ) else (
      if deg == 1 then (
        gensC := append(gensC, sub(g, {y=>1}));
        ) else squarefree := false  -- GB not squarefree in y
      )
    )

  C := ideal(gensC);
  N := ideal(gensN);

  -- Klein, Rajchgot. Lemma 2.6.
  if not squarefree then (
    print("Warning: Groebner basis not squarefree in " | toString y)
    return {false, C, N}
    )

  -- check that the intersection holds
  validOneStep := ( intersect(C, N + ideal(y)) == inyForm );

  if not validOneStep then (
    print("Warning: not a valid geometric vertex decomposition")
    return {false, C, N}
    )

  -- check unmixedness of both C and N
  isUnmixedC := isUnmixed C;
  isUnmixedN := isUnmixed N;

  if not (isUnmixedC or isUnmixedN) then (
    print("Warning: neither C nor N are unmixed")
    return {false, C, N}
    ) else (
      if not isUnmixedC then (
        print("Warning: C is not unmixed")
        return {false, C, N}
        )
      if not isUnmixedN then (
        print("Warning: N is not unmixed")
        return {false, C, N}
        )
      )

  -- redefine the ring and substitute C, N into the new ring
  R = (coefficientRing R)[ delete(y, indets) ];  -- notice this ring is defined globally
  C := sub(C, R);
  N := sub(N, R);

  return {true, C, N}
  )

--------------------------------------------------------------------------------

-* big isGVD, does the whole recursion thing *-

isGVD = method()
isGVD(Ideal) := I -> (

  if I == 0 or I == 1 or (isGeneratedByIndeterminates I) then return true
  if not (isUnmixed I) then return false

  -- original code doesn't run this check every time; set up an option for that
  -- Corollary 4.5, Klein and Rajchgot
  if (isHomogeneous I) and not isCM(R/I) then return false

  -- brute force check of all orders
  for y in (gens R) do (

    oneStep := oneStepGVD(I, y);
    isValid := oneStep_0;
    if not isValid then continue;  -- go back to top of for loop

    CisGVD := isGVD C;
    NisGVD := isGVD N;

    return (CisGVD and NisGVD)
    )

  -- if we are here, no indeterminate worked; return false
  return false
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
