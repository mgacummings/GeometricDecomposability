-* QUESTIONS/NOTES *-

-- If `R = QQ[x,y,z]`, what type is x? Need this for method declarations. Currently have these all marked with ``??''.

-- Need error catching

-- Feature idea: check for GVD up to substitution?

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

loadPackage "PrimaryDecomposition"  -* to check unmixedness *-
loadPackage "Depth"  -* for a CM check in isGVD *-

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (visible to end user) *-

--------------------------------------------------------------------------------

-* create a list of weights for the indeterminates in the ring *-

ringWeights = method()
ringWeights(PolynomialRing, ??) := (R, y) -> (
  -* y will be weighted 10, the rest of the indeterminates will be weighted 0 *-

  indets := gens R;
  weights := append( splice{ (#indets-1):0 } , 10);
  switch(index y, -1, weights)
  )

--------------------------------------------------------------------------------

-* define a new ring with a subset of the indeterminates *-

contractRing = method()
contractRing(PolynomialRing, ??) := (R, y) -> (
  -* create a new ring which has all the indeterminates of R except y *-
  indets := gens R;
  newIndets := delete(y, indets);
  QQ[newIndets]
  )

--------------------------------------------------------------------------------

-* check if C_{y, I} \cap (N_{y,I} + \langle y \rangle) = in_y(I) *-

-* NOTES *-
-* Not sure how to use the `sub` method here; R may not be the current ring, so how do we ensure that it is? *-
-* Possible error: what if I is zero/unit? It shouldn't be. If it's called from the main isGVD code, then we will have already checked this case. But if this function is called directly. Maybe we just have sub(I,R) as well to catch this. *-

isValidGVD = method()
isValidGVD(Ideal, Ideal, ??, Ideal) := (C, N, y, I) -> (
  C := sub(C, R);
  N := sub(N, R);
  intersect(C, N + ideal(y)) == ideal leadTerm(1,I)
  )

--------------------------------------------------------------------------------

-* check if ideal is squarefree ~~with an option to check only~~ with respect to one indeterminate *-
-* there's already `isSquareFree` , but it only works for monomial ideals. I think it would suffice to: set the custom weighting with y weighted 10, everything else 0, then run isSquareFree on the initial ideal. Is that equivalent? *-
-* assuming that this is ok, then here's an implementation *-

isSquareFreeInY = method()
isSquareFreeInY(Ideal, ??) := (I, y) -> (
  -* assuming that our ring is, again, R *-

  weights := ringWeights(R, y);
  R1 := QQ[gens R, MonomialOrder=>{Weights=>weights}, Global=>false];

  I := sub(I, R1);
  isSquareFree monomialIdeal leadTerm I
  )
-* ISSUE: we've now changed the ring we're working in; the next computations will be done in R1, not R *-
-* actually, with local assignment now, is that how that works? This is something to check actually in M2 *-
-* would it also work to make the last line of the method `use R;`, or is that going to mean that method returns the wrong thing? *-

-* would still be good to know whether the whole ideal is squarefree? *-
-* this can be computationally intensive -- leadTerm computes a GrÃ¶bner basis when an ideal is passed *-

isIdealSquareFree = method()
isIdealSquareFree(Ideal) := I -> (
  indets := gens R;
  all(apply(indets, y -> isSquareFreeInY(I, y)))
  )

--------------------------------------------------------------------------------

-* check if an ideal is unmixed *-

-* NOTES *-
-* Again, I have the problem with subbing into the current ring *-

isUnmixed = method()
isUnmixed(Ideal) := I -> (
  I := sub(I, R);
  D := primaryDecomposition I;
  d := apply(D, i -> dim(R/i));
  all(apply(d, i -> (i == d_0)), true)  -* list only contains true values *-
  )

--------------------------------------------------------------------------------

-* check if an ideal is generated by indeterminates *-
-* usual issue with (not) knowing R *-

isGeneratedByIndeterminates = method()
isGeneratedByIndeterminates(Ideal) := I -> (
  indets := gens R;
  gensI := first entries gens I;
  isSubset(gensI, indets)
  )


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* SMALL FUNCTIONS (invisible to end user) *-

--------------------------------------------------------------------------------

-* print function, prints only if asked *-

printIf = method()
printIf(Boolean, String) := (bool, str) -> (
  if bool then print str
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-* BIG FUNCTIONS *-

--------------------------------------------------------------------------------

-* do one step of a GVD: take I, find a GB; get C, N; check that they're unmixed and form a GVdecomp *-

-* --> need to decide where unmixedness checks happen *-
-* --> if it's when we compute C, N, then we need to pass that info to the isGVD function to not check it twice *-

oneGVDStep(Ideal) := I -> (

  )

--------------------------------------------------------------------------------

-* big isGVD, does the whole recursion thing *-

isGVD = method()
isGVD(Ideal) := I -> (
  if I == 0 or I == 1 or isGeneratedByIndeterminates I then return true
  if not (isUnmixed I) then return false

  -* original code doesn't run this check every time; set up the option for that *-
  if isHomogeneous I and not isCM(R/I) then return false

  for y in (gens R) do (




    )

  -* if we are here, no indeterminate worked; return false *-
  return false
  )

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
